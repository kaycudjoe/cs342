Exercise 13.1

a. Compare and contrast the store.put() command used here for KVLite and the em.persist() command you used for the GlassFish entity manager in the previous lab.
store.put() creates a new key-value  pair record in the database or updates an already existing record with that key.
em.persist() can only create new records as opposed to updating previous ones.

b. Compare and contrast the store.put() command with the standard Java hashtable’s myHashTable.put() command.
Store.put() and myHashTable.put() basically do the same thing as they both create a key to reference a specific value associated with that key.
myHashTable.put() writes to the hash table which is stored in the  main memory  whereas Store.put() writes to the KVLite store.

Exercise 13.2
a. Compare and contrast KVLite keys with relational database keys.
Foreign keys in relational databases work both ways as it create a relationship between the tables.
The KVLite keys however work in just one direction.

Exercise 13.3
a. So far, the implementation has only dealt with records in one relational table, Movie.
Explain how a key-value database might implement the one-to-many join relationships commonly implemented in relational databases using foreign keys.
The key-value database implements the one-to-many relationships using a tree structure which allows multiple values for a given key.

b.   KVLite requires that there be a key, but it is possible to have an “empty” value.
Such a value can be created using Value.createValue(new byte[0]). Where might one need such a construct?
To represent a NULL value (like NULL in relational databases)