Karen Cudjoe CS 342
Guide 4
1. Read Chapter 14 (focus primarily on Sections 14.1-2, 14.3.1-3, 14.5-6) — It’s ok to submit rather fuzzy or even empty answers on the material specifically marked for Wednesday’s discussion.a. Explain the four informal guidelines discussed in Section 14.1.i. Design a relation schema so that it is easy to explain its meaning: Do not combine attributes from multiple entity types and relationship types into a single relation. If a relation schema corresponds to one entity type or one relationship type, it is straightforward to explain its meaning. Otherwise, if the relationship corresponds to a mixture of multiple entities and relationships, semantic ambiguities will result and the result cannot be explained. 
ii. Design the base relation schemas so that no insertion, deletion or modification anomalies are present in the relations. If any anomalies are present, note them clearly and make sure that the programs that update the database will operate correctly.
 iii. Avoid placing attributes in a base relation whose values may frequently be NULL. If nulls are unavoidable, make sure that they apply in exceptional cases only and do not apply to many tuples in the relation. 
iv. Design relation schemas so that they can be joined with equality conditions on attributes that are appropriately related (primary key, foreign key) pairs in a way that guarantees that no spurious tuples are generated. Avoid relations that contain matching attributes that are nt (foreign key, primary key) combinations because joining on such attributes may produce spurious tuples. b. Explain the terms functional dependency (for Monday, see Section 14.2) and multi-valued dependency (for Wednesday, see Section 14.6) by giving an example of each and showing how it satisfies the term’s formal definition.i. Functional Dependency:A functional dependency is a constraint between two sets of attributes from the database. Definition: A functional dependency, denoted by X  Y, between two sets of attributes X and Y that are subsets of a universal relation schema R specifies a constraint on the possible tuples that can form a relation state r of R. The constraint is that, for any two tuples t1 and t2 in r that have t1[X] = t2[x], they must also have t1[Y] = t2[Y. This means the values of the Y component of a tuple in r depend on, or are determined by, the values of the X component, or the values of the X component of a tuple uniquely determine the values of the Y component. Example 1: {State, Driver_license_number}  Ssn should normally hold for any adult in the United States and hence should hold whenever these attributes appear in a relation. Example 2: FD Zip_code  Area_code is used to exist as a relationship between postal codes and telephone number codes in the United States, but with the proliferation of telephone area codes it is no longer true. ii. Multi-valued DependencyA full constraint between two sets of attributes in a relationDefinition. A multivalued dependency XY specified on relation schema R, where X and Y are both subsets of R, specifies the following constraint on any relation state r of R: If two tuples t1 and t2 exist in r such that t1[X] = t2[X], then two tuples t3 and t4 should also exist in r with the following properties, where we use Z to denote (R − (X  Y)): 	t3[X] = t4[X] = t1[X] = t2[X] 	t3[Y] = t1[Y] and t4[Y] = t2[Y] 	t3[Z] = t2[Z] and t4[Z] = t1[Z] 	Example: EMP (Ename, Pname, Dname): This relation has multivalued d	ependency:
	Ename  Pname	
	Ename  Dnamec. Review the formal definitions of these terms: superkey; key (see Section 14.3.3). Definition: A superkey of a relation schema R = {A1, A2, ... , An} is a set of attributes S ⊆ R with the property that no two tuples t1 and t2 in any legal relation state r of R will have t1[S] = t2[S]. A key K is a superkey with the additional property that removal of any attribute from K will cause K not to be a superkey anymore. The difference between a key and a superkey is that a key has to be minimal; that is, if we have a key K = {A1, A2, ... , Ak} of R, then K  {Ai} is not a key of R for any Ai, 1 ≤ i ≤ k. 

d. Explain BCNF (for Monday, see Section 14.5) and 4NF (for Wednesday, see Section 14.6) by giving an example relation and proving whether its schema conforms (or fails to conform) to the definitions of each normal form.i. BCNF: Boyce-Codd normal form (BCNF) A relation schema R is in BCNF if whenever a nontrivial functional dependency X  A holds in R, then X is a superkey of R. BCNF was proposed as a simpler form of 3NF, but it was found to be stricter than 3NF. That is, every relation in BCNF is also in 3NF; however, a relation in 3NF is not necessarily in BCNF. Although 3NF allows functional dependencies that conform to the clause (b) in the 3NF definition, BCNF disallows them and hence is a stricter definition of a normal form. ii.4NF – Fourth normal FormDefinition. A relation schema R is in 4NF with respect to a set of dependencies F (that includes functional dependencies and multivalued dependencies) if, for every nontrivial multivalued dependency X  Y in F+,  X is a superkey for R. 4NF is violated when a relation has undesirable multivalued dependencies and hence can be used to identify and decompose such relations. e. Explain when one would one want to normalize a relational schema and when one might want to de-normalize one.i.Normalized databases fair very well under conditions where the applications are write-intensive and the write-load is more than the read-load. Normalized databases are necessary when applications require more of writing than reading. The goal of normalization is to eliminate redundancies. 
ii.Denormalized databases fair well under heavy read-load and when the application is read intensive. Denormalization is necessary when applications require more reading than writing. Denormalization occurs when with immutable data and append-only scenarios. 2. Review Section 15.1.1 well enough to be able to define Armstrong’s axioms (IR1–3) and closures.a. Armstrong’s axioms (IR1–3) IR1 (reflexive rule): If X Y, then X YIR2 (augmentation rule): {X Y} |= XZ YZIR3 (transitive rule): {X Y, Y Z} |= X Zb.Closures.Formally, the set of all dependencies that include F as well as all dependencies that can be inferred from F is called the closure of F; it is denoted by F+.The closure F+ of F is the set of all functional dependencies that can be inferred from F.